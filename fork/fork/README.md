# 进程fork
## 简介
刚fork后，父子进程两个地址空间数据完全相同，各进程空间数据是完全独立的。
如果变量父子进程都是只读操作，此时物理空间只有一个变量
如果变量在父进程或者子进程发生改变，物理空间就会多出一份。此时有两个物理空间
如果父子进程都改变变量，变量都各复制一份父子进程指向复制的变量，变量有三分
总结：读时共享，写时复制,父子进程所有变量(局部变量与全局变量)都不共享。
父子进程不能使用全局变量进行通信。
## fork返回值
- 父进程返回子进程id
- 子进程返回0
## 子进程创建成功后代码运行位置
- fork()函数之后
## 父子进程执行顺序
- 不确定、谁抢到CPU谁先执行
## 函数
- 创建子进程|fork()|
- 获取自己的进程id|getpid()|
- 获取自己的父亲进程的id|getppid()|
- 
## shell终端命令
- ps|查看当前用户进程信息
- ps a|查看所有用户进程信息
- ps au|详细显示进程信息
- ps aux|显示不依赖终端的进程
- ps ajx|显示PPID父进程 PID本进程 PGID组进程id SID
- (ps ajx | grep bash) | 查找bash进程
- kill|向进程发送信号
- kill -l|查看所有信息宏
- kill -9 $(pid)|无条件杀死进程
- kill -SIGKILL $(pid)|无条件杀死进程
- top|实时动态显示进程信息
## exec函数族
- 让父子进程执行毫不相关的操作
### 函数
一般使用exec前需要fock创建子进程，用子进程使用exec。
#### int execl(const char\* path, const char\* arg, ..., NULL);
- path | 要执行的程序
- arg  | 第一个arg 站位作用随便写
- ...  | 命令参数
- NULL | 标志这参数的完成
- 例如 | execl("/bin/ls" , "ls", "-l", "-a", "-h", "-i", NULL);
#### int execlp(const char\* path, const char\* arg, ..., NULL);
- 多用于执行系统自带的程序(PATH环境变量目录里的程序)
- 自动去PATH路径里去找程序，不需要指定绝对路径
- 例如 | execlp("ls" , "ls", "-l", "-a", "-h", "-i", NULL);
## 孤儿进程
父进程提前子进程结束，此时子进程(孤儿进程)由init进程领养
目的为了释放系统资源
- 进程结束之后能够释放用户区空间
- 不能释放PCB，PCB必须由父进程释放
## 僵尸进程
子进程结束但父进程没有结束，父进程不去释放子进程PCB，子进程就会变成僵尸进程
僵尸进程是一个已经死掉的进程 +Z
hqf      10561  0.0  0.0      0     0 pts/3    Z+   21:53   0:00 [a.out] <defunct>
僵尸进程杀不死，因为已经死了只是没有释放资源，只能通过杀死父进程来释放资源
## wait 堵塞函数
- pid_t wait(int\* staus);
- 返回值:-1失败[已经没有子进程了] >0:回收子进程对应的pid
- 参数:判断子进程是如何死的:正常退出、被某信号杀死
- 调用一次只能回收一个子进程
## waitpid 可以设置堵塞或者非堵塞
- pid_t waitpid(pid_t pid, int\* status, int options);
- option = 0 ,函数为堵塞函数
- option = WNOHANG , 函数非堵塞
- pid:通过pid选择的回收子进程
- pid = 0 或者 -1: 代表所有子进程
注意wait waitpid 都是一次只能回收一个子进程
